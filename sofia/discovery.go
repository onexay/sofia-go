package sofia

import (
	"bytes"
	"fmt"
	"net"
	"time"

	"github.com/sirupsen/logrus"
)

/*
Broadcast UDP sent from factory reset devices on port 34569
{
	"Name" : "NetWork.NetCommon",
	"NetWork.NetCommon" :
	{
		"DeviceType" : 43,
		"GateWay" : "0x0101a8c0",
		"HostIP" : "0x0a01a8c0",
		"HostName" : "IPC_6a6b",
		"HttpPort" : 80,
		"MAC" : "00:12:31:09:b7:9e",
		"MaxBps" : 0,
		"MonMode" : "TCP",
		"SN" : "a5b23b431b14712e",
		"SSLPort" : 8443,
		"Submask" : "0x00ffffff",
		"TCPMaxConn" : 10,
		"TCPPort" : 34567,
		"TransferPlan" : "Quality",
		"UDPPort" : 34568,
		"UseHSDownLoad" : false,
		"Version" : "V4.02.R12.E7335520.12012.047502.00000",
		"BuildDate" : "2018-09-17 10:47:30" ,
		"OtherFunction": "D=2022-08-12 11:14:35 V=0832fc42ad047dc"
	},
	"Ret" : 100,
	"SessionID" : "0x00000000"
}
*/

type Discovery struct {
	logger   *logrus.Entry      // Contextual logger
	txBuf    *bytes.Buffer      // Transmit buffer
	interval time.Duration      // Interval for discovery broadcast
	addr     *net.UDPAddr       // Address
	baddr    *net.UDPAddr       // Broadcast address
	conn     *net.UDPConn       // Listen connection
	mQ       chan DeviceMessage // Message Q
}

// Create a new Discovery
//
func NewDiscovery(port uint16, interval uint32, logger *logrus.Logger) (*Discovery, error) {
	// Allocate a new discovery object
	discovery := new(Discovery)

	// Initialize Tx buffer
	discovery.txBuf = new(bytes.Buffer)

	// Save discovery interval
	discovery.interval = time.Second * time.Duration(interval)

	// Initialize address
	{
		discovery.baddr = new(net.UDPAddr)
		discovery.baddr.IP = net.IPv4bcast
		discovery.baddr.Port = int(port)

		discovery.addr = new(net.UDPAddr)
		discovery.addr.IP = net.IPv4zero
		discovery.addr.Port = int(port)
	}

	// Create channel
	discovery.mQ = make(chan DeviceMessage, 100)

	// Initialize logger
	discovery.logger = logger.WithFields(logrus.Fields{
		"module": "Discovery",
		"addr":   discovery.baddr.AddrPort().String(),
	})

	return discovery, nil
}

func dumpJSON(name string, amap map[string]interface{}, level string) {
	olevel := level
	level = level + "  "

	if len(olevel) == 0 {
		fmt.Printf("// Autogenerated struct, don't modify manually!\n")
		fmt.Printf("type %s struct {\n", name)
	} else {
		fmt.Printf("%s {\n", olevel)
	}

	for k, v := range amap {
		fmt.Printf("%s%s ", level, string(k))
		switch v.(type) {
		case map[string]interface{}:
			fmt.Printf("struct\n")
			dumpJSON("", v.(map[string]interface{}), level)
		case float64:
			fmt.Printf("uint32 `json: \"%s\"`", string(k))
		default:
			fmt.Printf("%T `json: \"%s\"`", v, string(k))

		}
		fmt.Printf("\n")
	}
	if len(olevel) > 0 {
		fmt.Printf("%s} `json: \"%s\"`\n", olevel, "PH")
	} else {
		fmt.Printf("%s}\n", olevel)
	}
}

// Message Q
//
func (discover *Discovery) MQ() *chan DeviceMessage {
	return &discover.mQ
}

// Discover task
//
func (discovery *Discovery) discover() {
	// Create a ticker
	ticker := time.NewTicker(discovery.interval)

	// Build discovery message
	msg := DeviceMessageHeader{
		msgId: IPSEARCH_REQ,
	}

	for {
		// Reset Tx buffer
		discovery.txBuf.Reset()

		// Encode message
		EncodeMessageHeader(&msg, discovery.txBuf)

		// Wait for tick
		<-ticker.C

		// Send message
		_, err := discovery.conn.WriteTo(discovery.txBuf.Bytes(), discovery.baddr)

		if err != nil {
			discovery.logger.Errorf("Tx discovery message fail [%s]", err.Error())
		} else {
			discovery.logger.Debugf("Tx discovery message success")
		}
	}
}

// Listener task
//
func (discovery *Discovery) listen() {
	// Create receive buffer
	buf := make([]byte, 1500)

	// Create a listener
	conn, err := net.ListenUDP("udp", discovery.addr)
	if err != nil {
		discovery.logger.Errorf("Listener create fail [%s]", err.Error())
		return
	}

	discovery.conn = conn
	discovery.logger.Debugf("Listener create success")

	for {
		// Read messages
		_, raddr, err := conn.ReadFrom(buf)

		if err != nil {
			discovery.logger.Errorf("Rx discovery message fail [%s]", err.Error())
			continue
		}

		// Decode message
		msg := DecodeMessage(buf)

		if msg.msgId == IPSEARCH_RSP {
			discovery.logger.Debugf("Rx discovery message success from [%s]", raddr.String())

			discovery.mQ <- msg
		}
	}
}

func (discovery *Discovery) Start() {
	// Start listener task
	go discovery.listen()

	// Start discovery task
	go discovery.discover()
}
